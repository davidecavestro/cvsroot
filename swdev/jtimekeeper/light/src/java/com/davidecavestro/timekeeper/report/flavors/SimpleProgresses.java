/*
 * SimpleProgresses.java
 *
 * Created on 31 gennaio 2005, 21.19
 */

package com.davidecavestro.timekeeper.report.flavors;

import com.davidecavestro.common.application.ApplicationData;
import com.davidecavestro.timekeeper.ApplicationContext;
import com.davidecavestro.timekeeper.report.AbstractDataExtractor;
import com.davidecavestro.timekeeper.report.filter.Target;
import com.davidecavestro.timekeeper.report.filter.TargetedFilterContainer;
import com.ost.timekeeper.model.Progress;
import com.ost.timekeeper.model.ProgressItem;
import java.util.*;
import org.jdom.*;

/**
 * Estrae i deti per il report degli avanzamenti.
 *
 * @author  davide
 */
public final class SimpleProgresses extends AbstractDataExtractor {
	/**
	 * Il tag radice.
	 */
	public final static String ROOT_ELEMENT = "plainprogresses";
	/**
	 * Il tag di avanzamento.
	 */
	public final static String PROGRESS_ELEMENT = "progress";
	/**
	 * Il tag di inizio avanzamento.
	 */
	public final static String FROM_ELEMENT = "from";
	/**
	 * Il tag di fine avanzamento.
	 */
	public final static String TO_ELEMENT = "to";
	/**
	 * Il tag di durata avanzamento.
	 */
	public final static String DURATION_ELEMENT = "duration";
	/**
	 * Il tag codice del nodo dell'avanzamento.
	 */
	public final static String NODE_CODE_ELEMENT = "nodecode";
	/**
	 * Il tag nome del nodo dell'avanzamento.
	 */
	public final static String NODE_NAME_ELEMENT = "nodename";
	/**
	 * Il tag 'descrizione' del nodo dell'avanzamento.
	 */
	public final static String NODE_DESCRIPTION_ELEMENT = "nodedescription";
	/**
	 * Il tag 'note' del nodo dell'avanzamento.
	 */
	public final static String NODE_NOTES_ELEMENT = "nodenotes";
	/**
	 * Il tag di descrizione dell'avanzamento.
	 */
	public final static String DESCRIPTION_ELEMENT = "description";
	/**
	 * Il tag di annotazioni dell'avanzamento.
	 */
	public final static String NOTES_ELEMENT = "notes";
	
	
	/**
	 * Identificatore dell'attributo <TT>FROM</TT> in qualit� di obiettivo di un filtro.
	 */
	public final static Target PROGRESS_FROM = new Target (){};
	
	/**
	 * Identificatore dell'attributo <TT>TO</TT> in qualit� di obiettivo di un filtro.
	 */
	public final static Target PROGRESS_TO = new Target (){};
	
	/**
	 * La radice del sottoalbero di interesse.
	 */
	private ProgressItem _subtreeRoot;
	
	private final ApplicationContext _context;
	/**
	 * Costruttore.
	 * @param filters i filtri da applicare.
	 * @param subtreeRoot la radice del sottoalbero di interesse per il report.
	 */
	public SimpleProgresses (final ApplicationContext context, final ProgressItem subtreeRoot, final TargetedFilterContainer[] filters) {
		super (filters);
		this._subtreeRoot = subtreeRoot;
		_context = context;
	}
	
	/**
	 * Ritorna la radice del sottoalbero di interesse per il report.
	 *
	 * @return la radice del sottoalbero di interesse per il report.
	 */
	public ProgressItem getSubtreeRoot (){
		return this._subtreeRoot;
	}
	
	/**
	 * Estrae e ritorna i dati per il report.
	 *
	 * @return i dati per il report.
	 */
	public org.jdom.Document extract () {
		final Element rootElement = new Element (ROOT_ELEMENT);
		final ApplicationData applicationData = _context.getApplicationData ();
		rootElement.addContent (new Comment ("Generated by "+applicationData.getApplicationInternalName ()+ " v."+applicationData.getVersionNumber ()+ " build "+applicationData.getBuildNumber ()));
		final org.jdom.Document data = new org.jdom.Document (rootElement);
		
		final  List aggregates = new ArrayList ();
		retrieveSubtreeProgressAggregates (aggregates, this._subtreeRoot);
		
		/*@todo implementare l'estrazione dati */
		for (final Iterator it = aggregates.iterator ();it.hasNext ();){
			final ProgressAggregate progressAggregate = (ProgressAggregate)it.next ();
			final Progress progress = progressAggregate.getProgress ();
			final ProgressItem node = progressAggregate.getNode ();
			if (match (PROGRESS_FROM, progress.getFrom ()) 
				&& match (PROGRESS_TO, progress.getTo ())){
					final Element progressElement = new Element (PROGRESS_ELEMENT);
					rootElement.addContent (progressElement);
				
				{
					final Element element = new Element (FROM_ELEMENT);
					element.setText (getText (progress.getFrom ()));
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (TO_ELEMENT);
					element.setText (getText (progress.getTo ()));
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (DURATION_ELEMENT);
					element.setText (getText (progress.getDuration ()));
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (DESCRIPTION_ELEMENT);
					element.setText (progress.getDescription ());
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (NOTES_ELEMENT);
					element.setText (progress.getNotes ());
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (NODE_CODE_ELEMENT);
					element.setText (node.getCode ());
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (NODE_NAME_ELEMENT);
					element.setText (node.getName ());
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (NODE_DESCRIPTION_ELEMENT);
					element.setText (node.getDescription ());
					progressElement.addContent (element);
				}
				
				{
					final Element element = new Element (NODE_NOTES_ELEMENT);
					element.setText (node.getNotes ());
					progressElement.addContent (element);
				}
			}
		}
		return data;
	}
	
	/**
	 * Dati aggregati agli avanzamenti, ad uso del generatore di report.
	 */
	private final class ProgressAggregate {
		private ProgressItem _node;
		private Progress _progress;
		
		public ProgressAggregate (final ProgressItem node, final Progress progress){
			this._node=node;
			this._progress=progress;
		}
		
		public ProgressItem getNode (){
			return this._node;
		}
		public Progress getProgress (){
			return this._progress;
		}
		
		public String toString (){
			final StringBuffer sb = new StringBuffer ();
			sb.append ("node: ").append (this._node);
			sb.append (" progress: ").append (this._progress);
			return sb.toString ();
		}
	}
	
	private void retrieveSubtreeProgressAggregates (final List result, final ProgressItem root){
		if (root==null){
			return;
		}
		for (final Iterator it = root.getPiecesOfWork ().iterator (); it.hasNext ();){
			result.add (new SimpleProgresses.ProgressAggregate (root, (Progress)it.next ()));
		}
		for (final Iterator it = root.getChildren ().iterator (); it.hasNext ();){
			retrieveSubtreeProgressAggregates (result, (ProgressItem)it.next ());
		}
	}
	
	/**
	 * Ritorna una rappresentazion ein formato stringa di questo estrattore.
	 *
	 * @return una stringa che rappresenta questo estrattore di dati.
	 */
	public String toString (){
		final StringBuffer sb = new StringBuffer ();
		sb.append (" subtree root: ");
		sb.append (this._subtreeRoot);
		return sb.toString ();
	}
}
