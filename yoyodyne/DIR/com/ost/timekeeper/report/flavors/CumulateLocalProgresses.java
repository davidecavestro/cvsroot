/*
 * CumulateLocalProgresses.java
 *
 * Created on 04 aprile 2005, 19.45
 */

package com.ost.timekeeper.report.flavors;

import com.ost.timekeeper.*;
import com.ost.timekeeper.model.*;
import com.ost.timekeeper.report.*;
import com.ost.timekeeper.report.filter.*;
import com.ost.timekeeper.util.Duration;
import com.ost.timekeeper.util.LocalizedPeriod;
import com.ost.timekeeper.util.LocalizedPeriodImpl;
import java.text.DecimalFormat;
import java.util.*;
import org.jdom.*;

/**
 * Estrae i deti per il report degli avanzamenti cumulati locali al nodo radice ed al sottoalbero.
 *
 * @author  davide
 */
public final class CumulateLocalProgresses extends AbstractDataExtractor {
	/**
	 * Il tag radice.
	 */
	public final static String ROOT_ELEMENT = "cumulatelocalprogresses";
	/**
	 * Il tag di periodo.
	 */
	public final static String PERIOD_ELEMENT = "period";
	/**
	 * Il tag di nome periodo.
	 */
	public final static String PERIODNAME_ELEMENT = "periodname";
	/**
	 * Il tag di nodo.
	 */
	public final static String PROGRESSITEM_ELEMENT = "progressitem";
	/**
	 * Il tag di nome del nodo.
	 */
	public final static String PROGRESSITEM_NAME_ELEMENT = "name";
	
	/**
	 * Il tag della gerarchia del nodo.
	 */
	public final static String PROGRESSITEM_HIERARCHY = "hierarchy";
	
	/**
	 * Il tag di durata avanzamenti in millisecondi.
	 */
	public final static String MILLISECDURATION_ELEMENT = "millisecduration";
	/**
	 * Il tag di durata avanzamenti.
	 */
	public final static String DURATION_ELEMENT = "duration";
	
	/**
	 * Il tag di durata avanzamenti del periodo.
	 */
	public final static String PERIOD_DURATION_ELEMENT = "periodduration";
	
	/**
	 * Il tag di nome.
	 */
	public final static String NAME_ELEMENT = "name";
	
	/**
	 * Il tag di descrizione.
	 */
	public final static String DESCRIPTION_ELEMENT = "description";
	
	/**
	 * Il tag di note.
	 */
	public final static String NOTES_ELEMENT = "notes";
	
	/**
	 * Il tag di progress.
	 */
	public final static String PROGRESS_ELEMENT = "progress";
	
	/**
	 * Identificatore dell'attributo <TT>FROM</TT> in qualita' di obiettivo di un filtro.
	 */
	public final static Target PROGRESS_FROM = new Target (){};
	
	/**
	 * Identificatore dell'attributo <TT>TO</TT> in qualita' di obiettivo di un filtro.
	 */
	public final static Target PROGRESS_TO = new Target (){};
	
	/**
	 * La radice del sottoalbero di interesse.
	 */
	private final ProgressItem _subtreeRoot;
	
	/**
	 * Il numero di giorni dilunghezza del periodo
	 */
	private final int _periodLength;
	
	/**
	 * Il numero di periodi di interesse
	 */
	private final int _periodCount;
	
	private final Date _date;
	
	/**
	 * Costruttore.
	 * @param date la data di partenza
	 * @param periodLength la lunghezza (in giorni) del periodo
	 * @param periodCount il numero di periodi
	 * @param filters i filtri da applicare.
	 * @param subtreeRoot la radice del sottoalbero di interesse per il report.
	 */
	public CumulateLocalProgresses (final ProgressItem subtreeRoot, final com.ost.timekeeper.report.filter.TargetedFilterContainer[] filters, final Date date, final int periodLength, final int periodCount) {
		super (filters);
		this._subtreeRoot = subtreeRoot;
		this._date=date;
		this._periodLength = periodLength;
		this._periodCount = periodCount;
	}
	
	/**
	 * Ritorna la radice del sottoalbero di interesse per il report.
	 *
	 * @return la radice del sottoalbero di interesse per il report.
	 */
	public ProgressItem getSubtreeRoot (){
		return this._subtreeRoot;
	}
	
	/**
	 * Estrae e ritorna i dati per il report.
	 *
	 * @return i dati per il report.
	 */
	public org.jdom.Document extract () {
		final Element rootElement = new Element (ROOT_ELEMENT);
		final ApplicationData applicationData = ApplicationData.getInstance ();
		rootElement.addContent (new Comment ("Generated by "+applicationData.getApplicationInternalName ()+ " v."+applicationData.getVersionNumber ()+ " build "+applicationData.getBuildNumber ()));
		final org.jdom.Document data = new org.jdom.Document (rootElement);
		
		final List localProgresses = new ArrayList ();
		final List subtreeProgresses = new ArrayList ();
		
		final Calendar now = new GregorianCalendar ();
		
		if (this._date!=null){
			now.setTime (this._date);
		}
		now.set (Calendar.HOUR_OF_DAY, 0);
		now.set (Calendar.MINUTE, 0);
		now.set (Calendar.SECOND, 0);
		now.set (Calendar.MILLISECOND, 0);
		//		now.roll (Calendar.DATE, 1);
		final Date periodFinishDate = new Date (now.getTime ().getTime ());
		
		now.add (Calendar.DAY_OF_YEAR, -1*_periodLength*_periodCount);
		final Date periodStartDate = new Date (now.getTime ().getTime ());
		
		final TimeCumulationScale map = new TimeCumulationScale (periodStartDate, periodFinishDate, _periodLength);
		
		//		Date currentPeriodStartDate = periodStartDate;
		//		Calendar c = new GregorianCalendar ();
		//		c.set (Calendar.HOUR_OF_DAY, 0);
		//		c.set (Calendar.MINUTE, 0);
		//		c.set (Calendar.SECOND, 0);
		//		c.set (Calendar.MILLISECOND, 0);
		
		//		final int step = 1;
		//		c.roll (Calendar.DATE, step);
		//		Date currentPeriodFInishDate = new Date (c.getTime ().getTime ());
		
		//		CumulationPeriod currentCumulationPeriod;
		final ProgressItem root = this._subtreeRoot;
		//		boolean jumpToNextPeriod = false;
		
		for (final Iterator it = root.getSubtreeProgresses ().iterator ();it.hasNext ();){
			final Progress progress = (Progress)it.next ();
			
			if (match (PROGRESS_FROM, progress.getFrom ()) 
				&& match (PROGRESS_TO, progress.getTo ())){
				/* filtri superati */
				map.addDuration (progress);
			}
		}
		
		for (final Iterator periodIterator = map.iterateCumulationPeriod ();periodIterator.hasNext ();){
			final CumulationPeriod cumulationPeriod = (CumulationPeriod)periodIterator.next ();
			
			final Element periodElement = new Element (PERIOD_ELEMENT);
			rootElement.addContent (periodElement);

			final String periodName = com.ost.timekeeper.util.CalendarUtils.getTimestamp (cumulationPeriod.getFrom (), "MM/dd");

			{
				final Element element = new Element (PERIODNAME_ELEMENT);
				element.setText (periodName);
				periodElement.addContent (element);
			}
			
			double periodDuration = 0;
			/* 
			 * pessimizzazione
			 * qui si duplica l'iterazione per calcolare la durata del periodo (abbstanza osceno, pardon)
			 */
			for (final Iterator nodeIterator = cumulationPeriod.iterateProgressItems ();nodeIterator.hasNext ();){
				final ProgressItem progressItem = (ProgressItem)nodeIterator.next ();
				final NodeProgresses detail = cumulationPeriod.getDetail (progressItem);
				periodDuration += detail.getDuration ();
			}
			
			for (final Iterator nodeIterator = cumulationPeriod.iterateProgressItems ();nodeIterator.hasNext ();){
				final ProgressItem progressItem = (ProgressItem)nodeIterator.next ();
				final NodeProgresses detail = cumulationPeriod.getDetail (progressItem);
				final double duration = detail.getDuration ();
				
				for (final Iterator detailIterator = detail.iterateProgresses ();detailIterator.hasNext ();){
					final CumulationPeriodNodeProgress nodeProgress = (CumulationPeriodNodeProgress)detailIterator.next ();
					final Progress progress = nodeProgress.getProgress ();
					final LocalizedPeriod periodOfInterest = nodeProgress.getPeriodOfInterest ();
					
					final Element progressElement = new Element (PROGRESS_ELEMENT);
					periodElement.addContent (progressElement); 
					{
						final Element element = new Element (PERIODNAME_ELEMENT);
						element.setText (periodName);
						progressElement.addContent (element);
					}
					{
						final Element element = new Element ("nodeandperiod");
						element.setText (progressItem.getName ()+periodName);
						progressElement.addContent (element);
					}
					{
						final Element element = new Element (DURATION_ELEMENT);
						element.setText (getDurationLabel (periodOfInterest.getDuration ()));
						progressElement.addContent (element);
					}
					{
						final Element element = new Element (DESCRIPTION_ELEMENT);
						element.setText (progress.getDescription ());
						progressElement.addContent (element);
					}
					{
						final Element element = new Element (NOTES_ELEMENT);
						element.setText (progress.getNotes ());
						progressElement.addContent (element);
					}
				}
				
				final Element nodeElement = new Element (PROGRESSITEM_ELEMENT);
				periodElement.addContent (nodeElement); 
				{
					final Element element = new Element (PROGRESSITEM_NAME_ELEMENT);
					element.setText (progressItem.getName ());
					nodeElement.addContent (element);
				}
				
				{
					/* Gerarchia */
					final Element element = new Element (PROGRESSITEM_HIERARCHY);
					final StringBuffer hierarchyData = new StringBuffer ();
					ProgressItem parent = progressItem.getParent ();
					while (parent!=null)
					{
						final StringBuffer ancestorData = new StringBuffer ();
						ancestorData.append ("/");
						final String code = parent.getCode ();
						if (code!=null && code.length ()>0){
							ancestorData.append (code).append (" - ");
						}
						ancestorData.append (parent.getName ()).append (" ");
						hierarchyData.insert (0, ancestorData);
						parent = parent.getParent ();
					}  
					element.setText (hierarchyData.toString ());
					nodeElement.addContent (element);
				}
				
				{
					final Element element = new Element (PERIODNAME_ELEMENT);
					element.setText (periodName);
					nodeElement.addContent (element);
				}
				
				{
					final Element element = new Element (PERIOD_DURATION_ELEMENT);
					element.setText (getDurationLabel (new Duration ((long)periodDuration)));
					nodeElement.addContent (element);
				}
				
				{
					final Element element = new Element (MILLISECDURATION_ELEMENT);
					element.setText (Double.toString (duration));
					nodeElement.addContent (element);
				}
				
				{
					final Element element = new Element (DURATION_ELEMENT);
					element.setText (getDurationLabel (new Duration ((long)duration)));
					nodeElement.addContent (element);
				}
			}
		}
		return data;
	}
	
	/**
	 * Ritorna una rappresentazion ein formato stringa di questo estrattore.
	 *
	 * @return una stringa che rappresenta questo estrattore di dati.
	 */
	public String toString (){
		final StringBuffer sb = new StringBuffer ();
		sb.append (" subtree root: ");
		sb.append (this._subtreeRoot);
		return sb.toString ();
	}
	
	private String getDurationLabel (Duration duration){
		if (duration==null){
			duration = Duration.ZERODURATION;
		}
		final StringBuffer sb = new StringBuffer ();

//		final long days = duration.getDays();
//
//		if (0==days){
//			sb.append ("__");
//		} else {
//			sb.append (durationNumberFormatter.format(duration.getDays()));
//		}
//		sb.append (" - ");
				
		sb.append (durationNumberFormatter.format (duration.getTotalHours ()))
		.append (":")
		.append (durationNumberFormatter.format (duration.getMinutes ()))
		.append (":")
		.append (durationNumberFormatter.format (duration.getSeconds ()));
		return sb.toString ();
	}
	
	
	private final class TimeCumulationScale {
		
		private SortedSet _set = new TreeSet ();
		
		public TimeCumulationScale (final Date from, final Date to, final int step){
			Date current = from;
			while (!current.after (to)){
				final Date currentEnd = new Date (current.getTime ()+step*Duration.MILLISECONDS_PER_DAY);
				_set.add (new CumulationPeriod (current, currentEnd));
				current = currentEnd;
			}
		}
		
		public Iterator iterateCumulationPeriod (){
			return this._set.iterator ();
		}
		
		//		public Cumulation getCumulation (CumulationPeriod cumulationPeriod){
		//			return (Cumulation)_map.get (cumulationPeriod);
		//		}
		
		public void addDuration (final Progress progress){
			
			/*
			 * pessimizzazione!!!
			 * @todo diminuire complessita' algoritmo di ricerca, magari usando la TreeMap come dio comanda (adesso no, ho sonno)
			 */
			//			final Map subMap = _map.subMap (from, to);
			final Set subSet = _set;
			for (final Iterator it = subSet.iterator ();it.hasNext ();){
				final CumulationPeriod cumulationPeriod = (CumulationPeriod)it.next ();
				cumulationPeriod.computeProgress (progress);
			}
		}
		
	}
	
	/**
	 * Un periodo.
	 */
	private final class CumulationPeriod extends LocalizedPeriodImpl implements Comparable {
		private final Map _map;
		
		public CumulationPeriod (final Date from, final Date to){
			super (from, to);
			if (null==from){
				throw new IllegalArgumentException ("Invalid 'from' value: "+from);
			}
			if (null==to){
				throw new IllegalArgumentException ("Invalid 'to' value: "+to);
			}
			this._map = new HashMap ();
		}
		
		public int compareTo (Object o) {
			return compareToStart ((CumulationPeriod)o);
		}
		
		public void computeProgress ( final Progress progress ){
			if (!this.intersects (progress)){
				return;
			}
			final LocalizedPeriod intersection = this.intersection (progress);
			final ProgressItem progressItem = progress.getProgressItem ();
			final double duration = intersection.getDuration ().getTime ();
			
			NodeProgresses detail = (NodeProgresses)_map.get (progressItem);
			if (detail==null){
				detail = new NodeProgresses ();
				_map.put (progressItem, detail);
			}
			detail.addProgress (progress, intersection);
		}
		
		/**
		 * Ritorna l'iteratore sui nodi implicati.
		 *
		 * @return l'iteratore sui nodi implicati.
		 */
		public Iterator iterateProgressItems (){
			return this._map.keySet ().iterator ();
		}
		
		public NodeProgresses getDetail (final ProgressItem progressItem){
			return (NodeProgresses)this._map.get (progressItem);
		}
	}
	
	/**
	 * Avanzamenti di interesse (nel periodo) per un nodo.
	 */
	private final class NodeProgresses {

		private double _duration = 0;
		private final List _nodeProgresses = new ArrayList ();
		public NodeProgresses (){}
		public void addProgress (final Progress progress, final LocalizedPeriod periodOfInterest){
			final double duration = periodOfInterest.getDuration ().getTime ();
			_duration += duration;
			_nodeProgresses.add (new CumulationPeriodNodeProgress (progress, periodOfInterest));
		}
		
		public double getDuration (){
			return this._duration;
		}
		
		public Iterator iterateProgresses (){
			return this._nodeProgresses.iterator ();
		}
	}
	
	/**
	 * Avanzamento con durata di interesse associata (nel periodo).
	 */
	private final class CumulationPeriodNodeProgress {
		private final Progress _progress;
		private final LocalizedPeriod _periodOfInterest;
		
		public CumulationPeriodNodeProgress (final Progress progress, final LocalizedPeriod periodOfInterest){
			this._progress = progress;
			this._periodOfInterest = periodOfInterest;
		}
		
		public Progress getProgress (){
			return this._progress;
		}
		
		public LocalizedPeriod getPeriodOfInterest (){
			return this._periodOfInterest;
		}
	}
	
	//	private final class Cumulation {
	//
	//		public double getDuration (){
	//			return this._Duration;
	//		}
	//	}
	
	private final DurationNumberFormatter durationNumberFormatter = new DurationNumberFormatter ();
	private static class DurationNumberFormatter extends DecimalFormat {
		public DurationNumberFormatter (){
			this.setMinimumIntegerDigits (2);
		}
	}
	
	
}
